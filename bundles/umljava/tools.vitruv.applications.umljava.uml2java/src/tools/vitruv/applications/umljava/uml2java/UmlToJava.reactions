import static extension tools.vitruv.domains.java.util.JavaPersistenceHelper.*;
import static extension tools.vitruv.applications.umljava.uml2java.UmlToJavaHelper.*;
import org.apache.log4j.PropertyConfigurator
import org.emftext.language.java.types.TypesFactory
import org.emftext.language.java.parameters.ParametersFactory
import mir.routines.umlToJava.ChangeJavaMethodVisibilityRoutine
import org.emftext.language.java.types.TypeReference
import org.eclipse.uml2.uml.PrimitiveType
import org.eclipse.uml2.uml.ParameterDirectionKind
import org.emftext.language.java.parameters.OrdinaryParameter
import org.emftext.language.java.parameters.Parameter
import org.emftext.language.java.types.NamespaceClassifierReference
import org.emftext.language.java.modifiers.Final
import java.util.Iterator
import org.eclipse.uml2.uml.VisibilityKind
import org.eclipse.uml2.uml.UMLFactory

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.emftext.org/java" as java

reactions: UmlToJava
in reaction to changes in uml
execute actions in java


reaction UmlClassCreated {
    after element uml::Class created and inserted in uml::Model[packagedElement]
    call createJavaClass(newValue)

}

routine createJavaClass(uml::Class umlClass) {
    action {
        val javaClass = create java::Class and initialize {
            //logger.info("NewJavaClass Corresp. : " + umlClass.name);
            javaClass.name = umlClass.name;
        }
        add correspondence between umlClass and javaClass
        val javaCompilationUnit = create java::CompilationUnit and initialize {
            javaCompilationUnit.name = umlClass.name;
            //javaCompilationUnit.namespaces += "testPackage" // FIXME Only for testing purposes
            javaCompilationUnit.classifiers += javaClass;
            persistProjectRelative(umlClass, javaCompilationUnit, buildJavaFilePath(javaCompilationUnit));
        }
        add correspondence between umlClass and javaCompilationUnit
    }
}

reaction UmlClassRenamed {
    after attribute replaced at uml::Class[name]
    call {
        //logger.info("UMlClassRename: " + affectedEObject + " | " + newValue);
        renameJavaClass(affectedEObject)
}}

routine renameJavaClass(uml::Class umlClass) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
        val javaCompilationUnit = retrieve java::CompilationUnit corresponding to umlClass
    }
    action {
        update javaClass {
            javaClass.name = umlClass.name;
        }
        update javaCompilationUnit {
            javaCompilationUnit.name = umlClass.name;
            persistProjectRelative(umlClass, javaCompilationUnit, buildJavaFilePath(javaCompilationUnit));
        }
    }
}

reaction UmlClassDeleted {
    after element uml::Class deleted and removed from uml::Model[packagedElement]
    call deleteJavaClass(oldValue)
}

routine deleteJavaClass(uml::Class umlClass) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
        val javaCompilationUnit = retrieve java::CompilationUnit corresponding to umlClass
    }
    action {
        delete javaClass
        delete javaCompilationUnit

        //TODO: Schauen, ob Attribute Methoden automatisch mitgelöscht werden

    }
}

reaction UmlClassMadeFinal {
    after attribute replaced at uml::Class[isFinalSpecialization] 
    call setJavaClassFinal(affectedEObject)
}
routine setJavaClassFinal(uml::Class umlClass) {
    match {
        val jClass = retrieve java::Class corresponding to umlClass
    }
    action {
        val finalMod = create java::Final
        update jClass {
            setJavaModifier(jClass, finalMod, umlClass.isFinalSpecialization);
        }
    }
}

reaction UmlClassMadeAbstract {
    after attribute replaced at uml::Class[isAbstract]
    call setJavaClassAbstract(affectedEObject)
}

routine setJavaClassAbstract(uml::Class umlClass) {
    match {
        val jClass = retrieve java::Class corresponding to umlClass
    }
    action {
        val abstr = create java::Abstract
        update jClass {
            setJavaModifier(jClass, abstr, umlClass.abstract);
            
        }
    }
}

reaction UmlClassVisibilityChanged {
    after attribute replaced at uml::Class[visibility]
    call changeJavaClassVisibility(affectedEObject)
}

routine changeJavaClassVisibility(uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
    }
    action {
        update jClass {
            removeJavaVisibilityModifiers(jClass)
            jClass.addModifier(getJavaVisibility(uClass.visibility))
        }
    }
}

reaction UmlSuperClassChanged {
    after element uml::Generalization inserted in uml::Class[generalization]
    call changeJavaSuperClass(newValue.general as org.eclipse.uml2.uml.Class, affectedEObject)

}

routine changeJavaSuperClass(uml::Class superUMLClass, uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
        val superJavaClass = retrieve java::Class corresponding to superUMLClass
    }
    action {
        update jClass {
            jClass.extends = createTypeReference(null, superJavaClass);
            
        }
    }
}

reaction UmlSuperClassDeleted {
    after element uml::Generalization removed from uml::Class[generalization]
    call deleteJavaSuperClass(affectedEObject)
}

routine deleteJavaSuperClass(uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
    }
    action {
        update jClass {
            jClass.extends = null;
        }
    }
}

reaction UmlInterfaceImplementCreated {
    after element uml::Interface inserted in uml::InterfaceRealization[supplier]
    call createJavaInterfaceImplement(newValue, affectedEObject.eContainer as org.eclipse.uml2.uml.Class)
}

routine createJavaInterfaceImplement(uml::Interface uI, uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
        val jI = retrieve java::Interface corresponding to uI
    }
    action {
        update jClass {
            jClass.implements += createTypeReference(null, jI);
        }
        call {
            val list = addInterfaceMethodsToUmlClass(uI, uClass)
            for (org.eclipse.uml2.uml.Operation op : list) {
                createJavaMethod(uClass, op)
            }
        }
    }
}

reaction UmlInterfaceImplementDeleted {
    after element uml::InterfaceRealization removed from uml::Class[interfaceRealization]
    call deleteJavaInterfaceImplement(oldValue.suppliers.head as org.eclipse.uml2.uml.Interface , affectedEObject)
}

routine deleteJavaInterfaceImplement(uml::Interface uI, uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
        val jI = retrieve java::Interface corresponding to uI
    }
    action {
        update jClass {
            removeClassifierFromIterator(jClass.implements.iterator, jI) 
        }
        call {
            val list = removeInterfaceMethodsFromUmlClass(uI, uClass)
            uClass.createOwnedOperation("testMeth", null, null, null);
            for (org.eclipse.uml2.uml.Operation op : list) {
                deleteJavaMethod(op)
                op.destroy;
            }
        }
    }
}



reaction UmlInterfaceCreated {
    after element uml::Interface created and inserted in uml::Model[packagedElement]
    call createJavaInterface(newValue)
}

routine createJavaInterface(uml::Interface umlInterface) {
    action {
        val javaInterface = create java::Interface and initialize {
            javaInterface.name = umlInterface.name;
        }
        add correspondence between umlInterface and javaInterface
        val javaCompilationUnit = create java::CompilationUnit and initialize {
            javaCompilationUnit.name = umlInterface.name;
            javaCompilationUnit.classifiers += javaInterface;
            persistProjectRelative(umlInterface, javaCompilationUnit, buildJavaFilePath(javaCompilationUnit));
        }
        add correspondence between umlInterface and javaCompilationUnit
    }
}

reaction UmlInterfaceRenamed {
    after attribute replaced at uml::Interface[name]
    call renameJavaInterface(affectedEObject)
}

routine renameJavaInterface(uml::Interface umlInterface) {
    match {
        val jInterface = retrieve java::Interface corresponding to umlInterface
        val jCompUnit = retrieve java::CompilationUnit corresponding to umlInterface
    }
    action {
        update jInterface {
            jInterface.name = umlInterface.name;
        }
        
        update jCompUnit {
            jCompUnit.name = umlInterface.name;
            persistProjectRelative(umlInterface, jCompUnit, buildJavaFilePath(jCompUnit));
        }
    }
}

reaction UmlInterfaceDeleted {
    after element uml::Interface deleted and removed from uml::Model[packagedElement]
    call deleteJavaInterface(oldValue)
}


routine deleteJavaInterface(uml::Interface umlInterface) {
    match {
         val jInterface = retrieve java::Interface corresponding to umlInterface
         val jCompUnit = retrieve java::CompilationUnit corresponding to umlInterface
    }
    action {
        delete jInterface
        delete jCompUnit
    }
}
 
reaction UmlSuperInterfaceChanged {
    after element uml::Generalization inserted in uml::Interface[generalization]
    call changeJavaSuperInterface(newValue.general as org.eclipse.uml2.uml.Interface, affectedEObject)
}

routine changeJavaSuperInterface(uml::Interface superUMLInterface, uml::Interface uI) {
    match {
        val jI = retrieve java::Interface corresponding to uI
        val superJavaInterface = retrieve java::Interface corresponding to superUMLInterface
    }
    action {
        update jI {
            jI.extends += createTypeReference(null, superJavaInterface)
        }
    }
}

reaction UmlSuperInterfaceDeleted {
    after element uml::Generalization removed from uml::Interface[generalization]
    call deleteJavaSuperInterface(oldValue.general as org.eclipse.uml2.uml.Interface, affectedEObject)
}

routine deleteJavaSuperInterface(uml::Interface superUMLInterface, uml::Interface uI) {
    match {
        val jI = retrieve java::Interface corresponding to uI
        val javaSuperInterface = retrieve java::Interface corresponding to superUMLInterface
    }
    action {
        update jI {
            removeClassifierFromIterator(jI.extends.iterator, javaSuperInterface)
        }
    }
}



reaction UmlAttributeCreated {
    after element uml::Property created and inserted in uml::Class[ownedAttribute]
    call {
        createJavaAttribute(affectedEObject, newValue)
    }
}



routine createJavaAttribute(uml::Class umlClass, uml::Property umlAttribute) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
        
        val customTypeClass = retrieve optional java::Class corresponding to umlAttribute.type
    }
    action {
        val javaAttribute = create java::Field and initialize {
            if (umlAttribute.name == null) {
                javaAttribute.name = "DefaultAttributeName"
            } else {
                javaAttribute.name = umlAttribute.name;
            }
            javaAttribute.typeReference = createTypeReference(umlAttribute.datatype, customTypeClass);    
        }
        update javaClass {
          javaClass.members += javaAttribute;
        }
        add correspondence between umlAttribute and javaAttribute
    }
}


reaction UmlAttributeRenamed {
    after attribute replaced at uml::Property[name]
    call renameJavaAttribute(affectedEObject)
}

//TypedElement kann Attribut oder Parameter sein
routine renameJavaAttribute(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        update jAttr {
            jAttr.name = umlAttr.name
        }
    }
}

reaction UmlAttributeDeleted {
    after element uml::Property deleted and removed from uml::Class[ownedAttribute]
    call deleteJavaAttribute(oldValue)
}

routine deleteJavaAttribute(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        delete jAttr
    }
}

reaction UmlMethodCreated {
    after element uml::Operation created and inserted in uml::Class[ownedOperation]
    call {
        createJavaMethod(affectedEObject, newValue)       
    }
}

routine createJavaMethod(uml::Class uClass, uml::Operation umlOp) {
    match {
        
        val javaClass = retrieve java::Class corresponding to uClass
        val customTypeClass = retrieve optional java::Class corresponding to umlOp.type
    }
    action {
      
        val javaMethod = create java::ClassMethod and initialize {
            if (umlOp.name == null) {
                javaMethod.name = "DefaultMethodName"
            } else {
                javaMethod.name = umlOp.name;
            }
            javaMethod.typeReference = createTypeReference(umlOp.type, customTypeClass)
        }
        update javaClass {
            javaClass.members += javaMethod;
            logger.info("Correspondence Added: " + umlOp + ", " + javaMethod)
        }
        add correspondence between umlOp and javaMethod
    }
}


reaction UmlMethodRenamed {
    after attribute replaced at uml::Operation[name]
    call renameJavaMethod(affectedEObject)
}
//Geht für ClassMethod und InterfaceMethod
routine renameJavaMethod(uml::Operation umlOp) {
    match {
        val jMeth = retrieve java::Method corresponding to umlOp
    }
    action {
        update jMeth {
            jMeth.name = umlOp.name
        }
    }
}

reaction UmlClassMethodDeleted {
    after element uml::Operation deleted and removed from uml::Class[ownedOperation]
    call deleteJavaMethod(oldValue)
}

reaction UmlInterfaceMethodDeleted {
    after element uml::Operation deleted and removed from uml::Interface[ownedOperation]
    call deleteJavaMethod(oldValue)
}

//Geht für ClassMethod und InterfaceMethod
routine deleteJavaMethod(uml::Operation umlOp) {
    match {
        val jMeth = retrieve java::Method corresponding to umlOp
    }
    action {
        delete jMeth
    }
}


reaction UmlParameterCreated {
    after element uml::Parameter created and inserted in uml::Operation[ownedParameter]
    call createJavaParameter(affectedEObject, newValue)

}
//Geht für ClassMethod und InterfaceMethod?
routine createJavaParameter(uml::Operation uMeth, uml::Parameter umlParam) {
    match {
        val javaMethod = retrieve java::Method corresponding to uMeth
        val customType = retrieve optional java::Class corresponding to umlParam.type
    }
    action {
        val javaParam = create java::OrdinaryParameter and initialize {
            if (umlParam.name != null) {
                javaParam.name = umlParam.name;
            } else {
                javaParam.name = "Defaultname";
            }
            javaParam.typeReference = createTypeReference(umlParam.type, customType)
        }
        add correspondence between javaParam and umlParam
        update javaMethod {
            javaMethod.parameters += javaParam;
        }
    }
}

reaction UmlParameterRenamed {
    after attribute replaced at uml::Parameter[name]
    call renameJavaParameter(affectedEObject)
}

routine renameJavaParameter(uml::Parameter uParam) {
    match {
        val jParam = retrieve java::OrdinaryParameter corresponding to uParam
    }
    action {
        update jParam {
            jParam.name = uParam.name;
        }
    }
}

reaction UmlParameterDeleted {
    after element uml::Parameter deleted and removed from uml::Operation[ownedParameter]
    call deleteJavaParameter(oldValue)
}

routine deleteJavaParameter(uml::Parameter uParam) {
    match {
        val jParam = retrieve java::OrdinaryParameter corresponding to uParam
    }
    action {
        delete jParam //TODO Ist Param wirklich aus JavaMethod.parameters gelöscht?
    }
}

//Bei Änderung eines Parameters oder ReturnTypes
reaction UmlParameterTypeChanged {
    after element uml::Type replaced at uml::Parameter[type]
    call {
        changeJavaParameterType(affectedEObject, newValue)
        
        }
}

routine changeJavaParameterType(uml::Parameter uParam, uml::Type uType) {
    match {
        val jParam = retrieve optional java::OrdinaryParameter corresponding to uParam
        val jMeth = retrieve java::Method corresponding to uParam.operation
        val customClass = retrieve optional java::Class corresponding to uType
    }
    action {
        update jParam {
            val jType = createTypeReference(uType, customClass);
            if (uParam.direction.equals(ParameterDirectionKind.RETURN_LITERAL)) {
                jMeth.typeReference = jType;
                if (jParam != null) {
                    //call deleteJavaParameter(jParam)
                }
            } else {
                jParam.typeReference = jType;
            }
            
        }
    }
}

reaction UmlMethodReturnTypeCreated {
    after attribute replaced at uml::Parameter[direction]
    call createJavaMethodReturnType(affectedEObject)

        
}

//TODO Für ClassMethod & InterfaceMethod gleichzeitig anwendbar?
routine createJavaMethodReturnType(uml::Parameter uParam) {
    match {
        val javaMethod = retrieve java::Method corresponding to uParam.operation
        val jParam = retrieve java::OrdinaryParameter corresponding to uParam
        val returnType = retrieve java::Class corresponding to uParam.type
        
    }
    action {

        update javaMethod {
            if (uParam.direction.equals(ParameterDirectionKind.RETURN_LITERAL)) {
                javaMethod.typeReference = createTypeReference(uParam.type, returnType);
            } else {
                javaMethod.typeReference = TypesFactory.eINSTANCE.createVoid; //d. h. kein Return
            }
            
        }
        
    }
        //add correspondence between jType and uParam
}



reaction UmlAttributeTypeChanged {
    after element uml::Type replaced at uml::Property[type]
    call changeJavaAttributeType(affectedEObject, newValue)
}

routine changeJavaAttributeType(uml::Property uAttr, uml::Type uType) {
    match {
        val jAttr = retrieve java::Field corresponding to uAttr
        val customType = retrieve optional java::Class corresponding to uType
    }
    action {
        update jAttr {
            jAttr.typeReference = createTypeReference(uType, customType);
        }
    }
}
reaction UmlAttributeMadeFinal {
    after attribute replaced at uml::Property[isReadOnly]
    call setJavaAttributeFinal(affectedEObject) 
}

routine setJavaAttributeFinal(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        val finalMod = create java::Final
        update jAttr {
            setJavaModifier(jAttr, finalMod, umlAttr.isReadOnly);
        }
    }
}
 

//Feature definiert isStatic  -> kann u.a.Attribut oder Methode sein
reaction UmlFeatureMadeStatic {
    after attribute replaced at uml::Feature[isStatic]
    call setStatic(affectedEObject)
}

routine setStatic(uml::Feature uFeat) {
    match {
        //AnnotableAndModifiable kann u.a. Methode oder Attribut sein
        val jMod = retrieve java::AnnotableAndModifiable corresponding to uFeat
    }
    action {
        val staticMod = create java::Static
        update jMod {
            setJavaModifier(jMod, staticMod, uFeat.isStatic);
        }
    }
}

reaction UmlMethodMadeAbstract {
    after attribute replaced at uml::Operation[isAbstract] 
    call setJavaMethodAbstract(affectedEObject)
}

routine setJavaMethodAbstract(uml::Operation umlOp) {
    match {
        val javaClass = retrieve java::Class corresponding to umlOp.class_
        val javaMethod = retrieve java::ClassMethod corresponding to umlOp
    }
    action {
        val abstr = create java::Abstract
        update javaMethod {
            setJavaModifier(javaMethod, abstr, umlOp.abstract);
        }
        call {
            if (umlOp.isAbstract) {
                umlOp.class_.isAbstract = true;
                 val uOperation = UMLFactory.eINSTANCE.createOperation;
                 uOperation.name = "testMeth";
                 umlOp.class_.ownedOperations += uOperation;
                umlOp.class_.createOwnedOperation("testMeth2", null, null, null);
                setJavaClassAbstract(umlOp.class_)
            }
        }
    }    
}


reaction UmlAttributeVisibilityChanged {
    after attribute replaced at uml::Property[visibility]
    call changeJavaAttributeVisibility(affectedEObject)
}

routine changeJavaAttributeVisibility(uml::Property umlAttr) {
    match {
        val javaAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        update javaAttr {
            removeJavaVisibilityModifiers(javaAttr)
            javaAttr.addModifier(getJavaVisibility(umlAttr.visibility))
        }
    }
}

reaction UmlMethodVisibilityChanged {
    after attribute replaced at uml::Operation[visibility]
    call changeJavaMethodVisibility(affectedEObject)
}

routine changeJavaMethodVisibility(uml::Operation umlOp) {
    match {
        val jMeth = retrieve java::ClassMethod corresponding to umlOp
    }
    action {
        update jMeth {
            removeJavaVisibilityModifiers(jMeth)
            jMeth.addModifier(getJavaVisibility(umlOp.visibility))
        }
    }
}


reaction UmlInterfaceMethodCreated {
    after element uml::Operation created and inserted in uml::Interface[ownedOperation]
    call createJavaInterfaceMethod(newValue)
}

routine createJavaInterfaceMethod(uml::Operation umlOp) {
    match {
        val jInterface = retrieve java::Interface corresponding to umlOp.interface
        val customClassType = retrieve optional java::Class corresponding to umlOp.type
    }
    action {
        val javaMethod = create java::InterfaceMethod and initialize {
            if (umlOp.name == null) {
                javaMethod.name = "DefaultInterfaceMethodName";
            } else {
                javaMethod.name = umlOp.name;
            }
            javaMethod.typeReference = createTypeReference(umlOp.type, customClassType);
            javaMethod.makePublic;
            umlOp.visibility = VisibilityKind.PUBLIC_LITERAL;
            
        }
        add correspondence between umlOp and javaMethod
        update jInterface {
            logger.info("Correspondence InterfaceMethod: " + umlOp + ", " + javaMethod)
            jInterface.members += javaMethod;
        }
    }
}



reaction Log {
    after any change
    call {
        PropertyConfigurator.configure("log4j.properties")
    }
}