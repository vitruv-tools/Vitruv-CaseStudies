import static extension tools.vitruv.domains.java.util.JavaPersistenceHelper.*;
import static extension tools.vitruv.applications.umljava.uml2java.UmlToJavaHelper.*;
import org.apache.log4j.PropertyConfigurator
import org.emftext.language.java.types.TypesFactory
import org.emftext.language.java.parameters.ParametersFactory
import mir.routines.umlToJava.ChangeJavaMethodVisibilityRoutine
import org.emftext.language.java.types.TypeReference

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.emftext.org/java" as java

reactions: UmlToJava
in reaction to changes in uml
execute actions in java



reaction UmlClassCreated {
    after element uml::Class created and inserted in uml::Model[packagedElement]
    call createJavaClass(newValue)
}

routine createJavaClass(uml::Class umlClass) {
    action {
        val javaClass = create java::Class and initialize {
            javaClass.name = umlClass.name;
        }
        add correspondence between umlClass and javaClass
        val javaCompilationUnit = create java::CompilationUnit and initialize {
            javaCompilationUnit.name = umlClass.name;
            //javaCompilationUnit.namespaces += "testPackage" // FIXME Only for testing purposes
            javaCompilationUnit.classifiers += javaClass;
            persistProjectRelative(umlClass, javaCompilationUnit, buildJavaFilePath(javaCompilationUnit));
        }
        add correspondence between umlClass and javaCompilationUnit
    }
}

reaction UmlClassRenamed {
    after attribute replaced at uml::Class[name]
    call renameJavaClass(affectedEObject)
}

routine renameJavaClass(uml::Class umlClass) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
        val javaCompilationUnit = retrieve java::CompilationUnit corresponding to umlClass
    }
    action {
        update javaClass {
            javaClass.name = umlClass.name;
        }
        update umlClass {
            javaCompilationUnit.name = umlClass.name;
            persistProjectRelative(umlClass, javaCompilationUnit, buildJavaFilePath(javaCompilationUnit));
        }
    }
}

reaction UmlClassDeleted {
    after element uml::Class deleted and removed from uml::Model[packagedElement]
    call deleteJavaClass(oldValue)
}

routine deleteJavaClass(uml::Class umlClass) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
        val javaCompilationUnit = retrieve java::CompilationUnit corresponding to umlClass
    }
    action {
        delete javaClass
        delete javaCompilationUnit

        //TODO: Schauen, ob Attribute Methoden automatisch mitgelöscht werden

    }
}

reaction UmlClassMadeFinal {
    after attribute replaced at uml::Class[isFinalSpecialization] 
    call setJavaClassFinal(affectedEObject)
}
routine setJavaClassFinal(uml::Class umlClass) {
    match {
        val jClass = retrieve java::Class corresponding to umlClass
    }
    action {
        val finalMod = create java::Final
        update jClass {
            if (umlClass.isFinalSpecialization) {
                if (!jClass.hasModifier(finalMod.class)) {
                    jClass.addModifier(finalMod)
                }
            } else {
                jClass.removeModifier(finalMod.class)
            }
        }
    }
}

reaction UmlClassMadeAbstract {
    after attribute replaced at uml::Class[isAbstract]
    call setJavaClassAbstract(affectedEObject)
}

routine setJavaClassAbstract(uml::Class umlClass) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
    }
    action {
        val abstr = create java::Abstract
        update javaClass {
            if (umlClass.isAbstract) {
                if (!javaClass.hasModifier(abstr.class)) {
                    javaClass.addModifier(abstr)
                }
            } else {
                javaClass.removeModifier(abstr.class)
                
            }
            
        }
    }
}

reaction UmlClassVisibilityChanged {
    after attribute replaced at uml::Class[visibility]
    call changeJavaClassVisibility(affectedEObject)
}

routine changeJavaClassVisibility(uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
    }
    action {
        update jClass {
            removeJavaVisibilityModifiers(jClass)
            jClass.addModifier(getJavaVisibility(uClass.visibility))
        }
    }
}

reaction UmlSuperClassChanged {
    after element uml::Class inserted in uml::Class[general]
    call changeJavaSuperClass(newValue, affectedEObject)
}

routine changeJavaSuperClass(uml::Class superUMLClass, uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
        val superJavaClass = retrieve java::Class corresponding to superUMLClass
    }
    action {
        update jClass {
            jClass.extends = createTypeReference(null, superJavaClass);
        }
    }
}

reaction UmlInterfaceImplementCreated {
    after element uml::Interface inserted in uml::Class[interfaceRealization]
    call createJavaInterfaceImplement(newValue, affectedEObject)
}

routine createJavaInterfaceImplement(uml::Interface uI, uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
        val jI = retrieve java::Interface corresponding to uI
    }
    action {
        update jClass {
            jClass.implements += createTypeReference(null, jI);
            //TODO InterfaceMethoden adden?
        }
    }
}

reaction UmlInterfaceImplementDeleted {
    after element uml::Interface removed from uml::Class[interfaceRealization]
    call deletedJavaInterfaceImplement(oldValue, affectedEObject)
}

routine deletedJavaInterfaceImplement(uml::Interface uI, uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
        val jI = retrieve java::Interface corresponding to uI
    }
    action {
        update jClass {
            var int i = 0;
            for (TypeReference t : jClass.implements) {
                var type = t.target as org.emftext.language.java.classifiers.Interface
                if (jI.name.equals(type.name)) {
                    jClass.implements.remove(i);
                }
                i++;
            }
            //TODO InterfaceMethoden entfernen?
        }
    }
}

reaction UmlSuperClassDeleted {
    after element uml::Class removed from uml::Class[general]
    call deleteJavaSuperClass(affectedEObject)
}

routine deleteJavaSuperClass(uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
    }
    action {
        update jClass {
            jClass.extends = null;
        }
    }
}

reaction UmlInterfaceCreated {
    after element uml::Interface created and inserted in uml::Model[packagedElement]
    call createJavaInterface(newValue)
}

routine createJavaInterface(uml::Interface umlInterface) {
    action {
        val javaInterface = create java::Interface and initialize {
            javaInterface.name = umlInterface.name;
        }
        add correspondence between umlInterface and javaInterface
        val javaCompilationUnit = create java::CompilationUnit and initialize {
            javaCompilationUnit.name = umlInterface.name;
            javaCompilationUnit.classifiers += javaInterface;
            persistProjectRelative(umlInterface, javaCompilationUnit, buildJavaFilePath(javaCompilationUnit));
        }
        add correspondence between umlInterface and javaCompilationUnit
    }
}

reaction UmlInterfaceRenamed {
    after attribute replaced at uml::Interface[name]
    call renameJavaInterface(affectedEObject)
}

routine renameJavaInterface(uml::Interface umlInterface) {
    match {
        val jInterface = retrieve java::Interface corresponding to umlInterface
        val jCompUnit = retrieve java::CompilationUnit corresponding to umlInterface
    }
    action {
        update jInterface {
            jInterface.name = umlInterface.name;
        }
        
        update jCompUnit {
            jCompUnit.name = umlInterface.name;
            persistProjectRelative(umlInterface, jCompUnit, buildJavaFilePath(jCompUnit));
        }
    }
}

reaction UmlInterfaceDeleted {
    after element uml::Interface deleted and removed from uml::Model[packagedElement]
    call deleteJavaInterface(oldValue)
}


routine deleteJavaInterface(uml::Interface umlInterface) {
    match {
         val jInterface = retrieve java::Interface corresponding to umlInterface
         val jCompUnit = retrieve java::CompilationUnit corresponding to umlInterface
    }
    action {
        delete jInterface
        delete jCompUnit
    }
}
 
reaction UmlSuperInterfaceChanged {
    after element uml::Interface inserted in uml::Interface[general]
    call changeJavaSuperInterface(newValue, affectedEObject)
}

routine changeJavaSuperInterface(uml::Interface superUMLInterface, uml::Interface uI) {
    match {
        val jI = retrieve java::Interface corresponding to uI
        val superJavaInterface = retrieve java::Interface corresponding to superUMLInterface
    }
    action {
        update jI {
            jI.extends += createTypeReference(null, superJavaInterface)
        }
    }
}

reaction UmlSuperInterfaceDeleted {
    after element uml::Interface removed from uml::Interface[general]
    call deleteJavaSuperInterface(oldValue, affectedEObject)
}

routine deleteJavaSuperInterface(uml::Interface superUMLInterface, uml::Interface uI) {
    match {
        val jI = retrieve java::Interface corresponding to uI
        val superJavaInterface = retrieve java::Class corresponding to superUMLInterface
    }
    action {
        update jI {
            var int i = 0;
            for (TypeReference t : jI.extends) {
                var type = t.target as org.emftext.language.java.classifiers.Interface
                if (superJavaInterface.name.equals(type.name)) {
                    jI.extends.remove(i);
                }
                i++;
            }
        }
    }
}



reaction UmlAttributeCreated {
    after element uml::Property created and inserted in uml::Class[ownedAttribute]
    call {
        createJavaAttribute(affectedEObject, newValue)
    }
}



routine createJavaAttribute(uml::Class umlClass, uml::Property umlAttribute) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
        
        val customTypeClass = retrieve optional java::Class corresponding to umlAttribute.type
    }
    action {
        val javaAttribute = create java::Field and initialize {
            if (umlAttribute.name == null) {
                javaAttribute.name = "DefaultAttributeName"
            } else {
                javaAttribute.name = umlAttribute.name;
            }
            javaAttribute.typeReference = createTypeReference(umlAttribute.datatype, customTypeClass);    
        }
        update javaClass {
          javaClass.members += javaAttribute;
        }
        add correspondence between umlAttribute and javaAttribute
    }
}


reaction UmlAttributeRenamed {
    after attribute replaced at uml::Property[name]
    call renameJavaAttribute(affectedEObject)
}

//TypedElement kann Attribut oder Parameter sein
routine renameJavaAttribute(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        update jAttr {
            jAttr.name = umlAttr.name
        }
    }
}

reaction UmlAttributeDeleted {
    after element uml::Property deleted and removed from uml::Class[ownedAttribute]
    call deleteJavaAttribute(oldValue)
}

routine deleteJavaAttribute(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        delete jAttr
    }
}

reaction UmlMethodCreated {
    after element uml::Operation created and inserted in uml::Class[ownedOperation]
    call {
        createJavaMethod(affectedEObject, newValue)       
    }
}

routine createJavaMethod(uml::Class uClass, uml::Operation umlOp) {
    match {
        
        val javaClass = retrieve java::Class corresponding to uClass
        val customTypeClass = retrieve optional java::Class corresponding to umlOp.type
    }
    action {
      
        val javaMethod = create java::ClassMethod and initialize {
            if (umlOp.name == null) {
                javaMethod.name = "DefaultMethodName"
            } else {
                javaMethod.name = umlOp.name;
            }
            javaMethod.typeReference = createTypeReference(umlOp.type, customTypeClass)
        }
        update javaClass {
            javaClass.members += javaMethod;
        }
        add correspondence between umlOp and javaMethod
    }
}


reaction UmlMethodRenamed {
    after attribute replaced at uml::Operation[name]
    call renameJavaMethod(affectedEObject)
}
//Geht für ClassMethod und InterfaceMethod
routine renameJavaMethod(uml::Operation umlOp) {
    match {
        val jMeth = retrieve java::Method corresponding to umlOp
    }
    action {
        update jMeth {
            jMeth.name = umlOp.name
        }
    }
}

reaction UmlClassMethodDeleted {
    after element uml::Operation deleted and removed from uml::Class[ownedOperation]
    call deleteJavaMethod(oldValue)
}

reaction DeletedUmlInterfaceMethod {
    after element uml::Operation deleted and removed from uml::Interface[ownedOperation]
    call deleteJavaMethod(oldValue)
}

//Geht für ClassMethod und InterfaceMethod
routine deleteJavaMethod(uml::Operation umlOp) {
    match {
        val jMeth = retrieve java::Method corresponding to umlOp
    }
    action {
        delete jMeth
    }
}


reaction UmlParameterCreated {
    after element uml::Parameter created and inserted in uml::Operation[ownedParameter]
    call createJavaParameter(affectedEObject, newValue)
}
//Geht für ClassMethod und InterfaceMethod?
routine createJavaParameter(uml::Operation uMeth, uml::Parameter umlParam) {
    match {
        val javaMethod = retrieve java::Method corresponding to uMeth
        val customType = retrieve java::Class corresponding to umlParam.type
    }
    action {
        val javaParam = create java::OrdinaryParameter and initialize {
            javaParam.name = umlParam.name;
            javaParam.typeReference = createTypeReference(umlParam.type, customType)
        }
        add correspondence between javaParam and umlParam
        update javaMethod {
            javaMethod.parameters += javaParam;
        }
    }
}

reaction UmlParameterRenamed {
    after attribute replaced at uml::Parameter[name]
    call renameJavaParameter(affectedEObject)
}

routine renameJavaParameter(uml::Parameter uParam) {
    match {
        val jParam = retrieve java::OrdinaryParameter corresponding to uParam
    }
    action {
        update jParam {
            jParam.name = uParam.name;
        }
    }
}

reaction UmlParameterDeleted {
    after element uml::Parameter deleted and removed from uml::Operation[ownedParameter]
    call deleteJavaParameter(oldValue)
}

routine deleteJavaParameter(uml::Parameter uParam) {
    match {
        val jParam = retrieve java::OrdinaryParameter corresponding to uParam
    }
    action {
        delete jParam //TODO Ist Param wirklich aus JavaMethod.parameters gelöscht?
    }
}

reaction UmlParameterTypeChanged {
    after element uml::Type replaced at uml::Parameter[type]
    call changeJavaParameterType(affectedEObject, newValue)
}

routine changeJavaParameterType(uml::Parameter uParam, uml::Type uType) {
    match {
        val jParam = retrieve java::OrdinaryParameter corresponding to uParam
        val customClass = retrieve optional java::Class corresponding to uType
    }
    action {
        update jParam {
            jParam.typeReference = createTypeReference(uType, customClass);
        }
    }
}

reaction UmlMethodReturnTypeChanged {
    after element uml::Type replaced at uml::Operation[type]
    call changeJavaMethodReturnType(affectedEObject)
}

//TODO Für ClassMethod & InterfaceMethod gleichzeitig anwendbar?
routine changeJavaMethodReturnType(uml::Operation umlOp) {
    match {
        val javaMethod = retrieve java::Method corresponding to umlOp
        val returnType = retrieve java::Class corresponding to umlOp.type
        
    }
    action {
        update javaMethod {
            javaMethod.typeReference = createTypeReference(umlOp.datatype, returnType)
        }
    }
}

reaction UmlAttributeTypeChanged {
    after element uml::Type replaced at uml::Property[type]
    call changeJavaAttributeType(affectedEObject, newValue)
}

routine changeJavaAttributeType(uml::Property uAttr, uml::Type uType) {
    match {
        val jAttr = retrieve java::Field corresponding to uAttr
        val customType = retrieve java::Class corresponding to uType
    }
    action {
        update jAttr {
            jAttr.typeReference = createTypeReference(uType, customType);
        }
    }
}
reaction UmlAttributeMadeFinal {
    after attribute replaced at uml::Property[isReadOnly]
    call setJavaAttributeFinal(affectedEObject) 
}

routine setJavaAttributeFinal(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        val finalMod = create java::Final
        update jAttr {
            if (umlAttr.isReadOnly) {
                if (!jAttr.hasModifier(finalMod.class)) {
                    jAttr.addModifier(finalMod)
                }
            } else {
                jAttr.removeModifier(finalMod.class)
            }
        }
    }
}
 

//Feature definiert isStatic  -> kann u.a.Attribut oder Methode sein
reaction UmlFeatureMadeStatic {
    after attribute replaced at uml::Feature[isStatic]
    call setStatic(affectedEObject)
}

routine setStatic(uml::Feature uFeat) {
    match {
        //AnnotableAndModifiable kann u.a. Methode oder Attribut sein
        val jMod = retrieve java::AnnotableAndModifiable corresponding to uFeat
    }
    action {
        val staticMod = create java::Static
        update jMod {
            if (uFeat.isStatic) {
                if (!jMod.hasModifier(staticMod.class)) {
                    jMod.addModifier(staticMod)
                }
            } else {
                jMod.removeModifier(staticMod.class)
            }
        }
    }
}

reaction UmlMethodMadeAbstract {
    after attribute replaced at uml::Operation[isAbstract] 
    call setJavaMethodAbstract(affectedEObject)
}

routine setJavaMethodAbstract(uml::Operation umlOp) {
    match {
        val javaClass = retrieve java::Class corresponding to umlOp.class_
        val javaMethod = retrieve java::ClassMethod corresponding to umlOp
    }
    action {
        val abstr = create java::Abstract
        update javaMethod {
            if (umlOp.isAbstract) {
                if (!javaMethod.hasModifier(abstr.class)) {
                    javaMethod.addModifier(abstr)
                    //umlOp.class_.isAbstract = true;
                }
            } else {
                javaMethod.removeModifier(abstr.class)
            }
            
        }
    }    
}


reaction UmlAttributeVisibilityChanged {
    after attribute replaced at uml::Property[visibility]
    call changeJavaAttributeVisibility(affectedEObject)
}

routine changeJavaAttributeVisibility(uml::Property umlAttr) {
    match {
        val javaAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        update javaAttr {
            removeJavaVisibilityModifiers(javaAttr)
            javaAttr.addModifier(getJavaVisibility(umlAttr.visibility))
        }
    }
}

reaction UmlMethodVisibilityChanged {
    after attribute replaced at uml::Operation[visibility]
    call changeJavaMethodVisibility(affectedEObject)
}

routine changeJavaMethodVisibility(uml::Operation umlOp) {
    match {
        val jMeth = retrieve java::ClassMethod corresponding to umlOp
    }
    action {
        update jMeth {
            removeJavaVisibilityModifiers(jMeth)
            jMeth.addModifier(getJavaVisibility(umlOp.visibility))
        }
    }
}


reaction UmlInterfaceMethodCreated {
    after element uml::Operation created and inserted in uml::Interface[ownedOperation]
    call createJavaInterfaceMethod(newValue)
}

routine createJavaInterfaceMethod(uml::Operation umlOp) {
    match {
        val jInterface = retrieve java::Interface corresponding to umlOp.interface
        val customClassType = retrieve optional java::Class corresponding to umlOp.type
    }
    action {
        val javaMethod = create java::InterfaceMethod and initialize {
            if (umlOp.name == null) {
                javaMethod.name = "DefaultInterfaceMethodName";
            } else {
                javaMethod.name = umlOp.name;
            }
            javaMethod.typeReference = createTypeReference(umlOp.type, customClassType);
            javaMethod.makePublic;
            
        }
        add correspondence between umlOp and javaMethod
        update jInterface {
            jInterface.members += javaMethod;
        }
    }
}



reaction Log {
    after any change
    call {
        PropertyConfigurator.configure("log4j.properties")
    }
}