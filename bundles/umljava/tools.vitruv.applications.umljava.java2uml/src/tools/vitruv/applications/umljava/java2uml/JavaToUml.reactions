import org.eclipse.uml2.uml.VisibilityKind
import static tools.vitruv.applications.umljava.java2uml.JavaToUmlHelper.*;
import org.emftext.language.java.modifiers.*;
import org.emftext.language.java.classifiers.Interface;
import org.apache.log4j.PropertyConfigurator
import static tools.vitruv.applications.umljava.util.JavaUtil.*;
import static tools.vitruv.applications.umljava.util.UmlUtil.*;

//import tools.vitruv.applications.umljava.util.JavaVisibility;

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.emftext.org/java" as java

reactions: JavaToUml
in reaction to changes in java
execute actions in uml

reaction JavaClassCreated {
    after element java::Class created and inserted in java::CompilationUnit[classifiers]
    call createUmlClass(newValue)

}

routine createUmlClass(java::Class jClass) {
    action {
        val uClass = create uml::Class and initialize {
            uClass.name = jClass.name;
        }
        call {
            val uModel = getUmlModel(correspondenceModel)
            uModel.packagedElements += uClass;
            persistProjectRelative(jClass, uModel, ROOTMODELFILE)
        }
        add correspondence between uClass and jClass
        add correspondence between uClass and jClass.eContainer
    }
}

reaction JavaInterfaceCreated {
    after element java::Interface created and inserted in java::CompilationUnit[classifiers]
    call createUmlInterface(newValue)
}

routine createUmlInterface(java::Interface jI) {
    action {
        val uI = create uml::Interface and initialize {
            uI.name = jI.name;
            uI.visibility = VisibilityKind.PUBLIC_LITERAL
        }
        call {
            val uModel = getUmlModel(correspondenceModel)
            uModel.packagedElements += uI;
            persistProjectRelative(jI, uModel, ROOTMODELFILE)
        }
        add correspondence between uI and jI
        add correspondence between uI and jI.eContainer
    }
}

//java::ConcreteClassifier = {Annotation, Class, Interface, Enumeration}
reaction JavaClassifierRenamed {
    after attribute replaced at java::ConcreteClassifier[name]
    call renameUmlClassifier(affectedEObject)
}

//uml::Classifer = {Class, Interface, Enumeration, ...}
routine renameUmlClassifier(java::ConcreteClassifier jClass) {
    match {
        val uClass = retrieve uml::Classifier corresponding to jClass
        val jCompUnit = retrieve java::CompilationUnit corresponding to uClass
    }
    action {
        update uClass {
            uClass.name = jClass.name;
        }
        update jCompUnit {
            jCompUnit.name = jClass.name;
        }
    }
}

reaction JavaCompUnitDeleted {
    after element java::CompilationUnit removed as root
    call deleteUmlClassifier(oldValue.classifiers.head, oldValue)
}

reaction JavaClassifierDeleted {
    after element java::ConcreteClassifier deleted and removed from java::CompilationUnit[classifiers]
    call deleteUmlClassifier(oldValue, affectedEObject)
}

routine deleteUmlClassifier(java::ConcreteClassifier jClass, java::CompilationUnit jCompUnit) {
    match {
        val uClass = retrieve uml::Classifier corresponding to jClass
    }
    action {
        delete uClass
        delete jClass
        delete jCompUnit
    }
}

reaction JavaElementMadePublic {
    after element java::Public created and inserted in java::AnnotableAndModifiable[annotationsAndModifiers]
    call changeUmlNamedElementVisibility(affectedEObject, newValue)
}

routine changeUmlNamedElementVisibility(java::AnnotableAndModifiable jElem, java::Modifier mod) {
    match {
        val uElem = retrieve uml::NamedElement corresponding to jElem
    }
    action {
        update uElem {
            uElem.visibility = getUmlVisibilityKind(mod);
        }
    }
}
//TODO
/* 
reaction JavaClassMadePublic {
    after element java::Public created and inserted in java::Class[annotationsAndModifiers]
    call changeUmlClassVisibility(affectedEObject, newValue)
}*/
reaction JavaClassMadePrivate {
    after element java::Private created and inserted in java::Class[annotationsAndModifiers]
    call changeUmlClassVisibility(affectedEObject, newValue)
}
reaction JavaClassMadeProtected {
    after element java::Protected created and inserted in java::Class[annotationsAndModifiers]
    call changeUmlClassVisibility(affectedEObject, newValue)
}

reaction JavaClassMadePackagePrivate {
    after element java::Modifier deleted and removed from java::Class[annotationsAndModifiers]
    with oldValue instanceof Private
    || oldValue instanceof Public
    || oldValue instanceof Protected
    call changeUmlClassVisibility(affectedEObject, null)
}

routine changeUmlClassVisibility(java::Class jClass, java::Modifier mod) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
    }
    action {
        update uClass {
            uClass.visibility = getUmlVisibilityKind(mod);
        }
    }
}

reaction JavaClassMadeAbstract {
    after element java::Abstract created and inserted in java::Class[annotationsAndModifiers]
    call setUmlClassAbstract(affectedEObject, 1)
}

reaction JavaClassMadeNonAbstract {
    after element java::Abstract deleted and removed from java::Class[annotationsAndModifiers]
    call setUmlClassAbstract(affectedEObject, 0)
}

// TODO isAbstract: Boolean geht nicht?
// 1 = true
// 0 = false
routine setUmlClassAbstract(java::Class jClass, Int isAbstract) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
    }
    action {
        update uClass {
            if (isAbstract == 1) {
                uClass.isAbstract = true;
            } else if (isAbstract == 0) {
                uClass.isAbstract = false;
            } else {
                throw new IllegalArgumentException("Invalid isAbstract Value: " + isAbstract);
            }
        }
    }
}

reaction JavaSuperClassChanged {
    after element java::TypeReference replaced at java::Class[^extends]
    call  {
        clearUmlSuperClassifiers(affectedEObject)
        addUmlSuperClassifier(affectedEObject, getClassifierfromTypeRef(newValue))
    }
}

reaction JavaSuperClassRemoved {
    after element java::TypeReference removed from java::Class[^extends]
    call clearUmlSuperClassifiers(affectedEObject)
}

routine addUmlSuperClassifier(java::ConcreteClassifier jClass, java::ConcreteClassifier jSuper) {
    match {
        val uClass = retrieve uml::Classifier corresponding to jClass
        val uSuper = retrieve uml::Classifier corresponding to jSuper
    }
    action {
        update uClass {
            uClass.generals += uSuper;
        }
    }
}

routine clearUmlSuperClassifiers(java::ConcreteClassifier jClass) {
    match {
         val uClass = retrieve uml::Class corresponding to jClass
    }
    action {
        update uClass {
            uClass.generalizations.clear;
        }
    }
}

reaction JavaSuperInterfaceAdded {
    after element java::TypeReference inserted in java::Interface[^extends]
    call addUmlSuperClassifier(affectedEObject, getClassifierfromTypeRef(newValue))
}

reaction JavaSuperInterfaceRemoved {
    after element java::TypeReference removed from java::Interface[^extends]
    call removeUmlSuperInterface(affectedEObject, getClassifierfromTypeRef(oldValue))
}

routine removeUmlSuperInterface(java::Interface jI, java::ConcreteClassifier jSuper) {
    match {
        val uI = retrieve uml::Interface corresponding to jI
        val uSuper = retrieve uml::Interface corresponding to jSuper
    }
    action {
        update uI {
            removeClassifierFromIterator(uI.generals.iterator, uSuper)
        }
    }
}

reaction JavaClassImplementAdded {
    after element java::TypeReference created and inserted in java::Class[implements]
    call addUmlClassImplement(affectedEObject, getClassifierfromTypeRef(newValue) as Interface)
}

routine addUmlClassImplement(java::Class jClass, java::Interface jI) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
        val uI = retrieve uml::Interface corresponding to jI
    }
    action {
        update uClass {
            uClass.createInterfaceRealization("IR-" + uI.name, uI)
        }
    }
}

reaction JavaClassImplementRemoved {
    after element java::TypeReference removed from java::Class[implements]
    call removeUmlClassImplement(affectedEObject, getClassifierfromTypeRef(oldValue) as Interface)
}

routine removeUmlClassImplement(java::Class jClass, java::Interface jI) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
        val uI = retrieve uml::Interface corresponding to jI
    }
    action {
        update uClass {
            removeClassifierFromIterator(uClass.implementedInterfaces.iterator, uI)
        }
    }
}


reaction JavaClassMadeFinal {
    after element java::Final created and inserted in java::Class[annotationsAndModifiers]
    call setUmlClassFinal(affectedEObject, 1)
}

reaction JavaClassMadeNonFinal {
    after element java::Final deleted and removed from java::Class[annotationsAndModifiers]
    call setUmlClassFinal(affectedEObject, 0)
}

routine setUmlClassFinal(java::Class jClass, Int isFinal) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
    }
    action {
        update uClass {
            if (isFinal == 1) {
                uClass.isFinalSpecialization = true;
            } else if (isFinal == 0) {
                uClass.isFinalSpecialization = false;
            } else {
                throw new IllegalArgumentException("Invalid isFinal value: " + isFinal)
            }
        }
    }
}

reaction JavaClassMethodCreated {
    after element java::ClassMethod created and inserted in java::Class[members]
    call createUmlClassMethod(newValue, affectedEObject)
}

routine createUmlClassMethod(java::ClassMethod jMeth, java::Class jClass) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
        val customType = retrieve optional uml::Class corresponding to getClassifierfromTypeRef(jMeth.typeReference)
    }
    action {
        val uMeth = create uml::Operation and initialize {
            uMeth.name = jMeth.name;
            if (jMeth.typeReference != null) {
                uMeth.type = getUmlType(jMeth.typeReference, customType, getUmlModel(correspondenceModel))
            }
        }
        add correspondence between uMeth and jMeth
        update uClass {
            uClass.ownedOperations += uMeth;
        }
    }
}

reaction JavaInterfaceMethodCreated {
    after element java::InterfaceMethod created and inserted in java::Interface[members]
    call createUmlInterfaceMethod(newValue, affectedEObject)
}

routine createUmlInterfaceMethod(java::InterfaceMethod jMeth, java::Interface jI) {
    match {
        val uI = retrieve uml::Interface corresponding to jI
        val customType = retrieve optional uml::Class corresponding to getClassifierfromTypeRef(jMeth.typeReference)
    }
    action {
        val uMeth = create uml::Operation and initialize {
            uMeth.name = jMeth.name;
            if (jMeth.typeReference != null) {
                uMeth.type = getUmlType(jMeth.typeReference, customType, getUmlModel(correspondenceModel))
            }
        }
        add correspondence between uMeth and jMeth
        update uI {
            uI.ownedOperations += uMeth;
        }
    }
}

reaction JavaMethodRenamed {
    after attribute replaced at java::Method[name]
    call renameUmlMethod(affectedEObject)
}

routine renameUmlMethod(java::Method jMeth) {
    match {
        val uMeth = retrieve uml::Operation corresponding to jMeth
    }
    action {
        update uMeth {
            uMeth.name = jMeth.name;
        }
    }
}

reaction JavaMethodDeleted {
    after element java::Method deleted and removed from java::ConcreteClassifier[members]
    call deleteUmlMethod(oldValue)
}

routine deleteUmlMethod(java::Method jMeth) {
    match {
        val uMeth = retrieve uml::Operation corresponding to jMeth
    }
    action {
        delete uMeth
    }
}
/* 
reaction JavaMethodMadePublic {
    after element java::Public created and inserted in java::ClassMethod[annotationsAndModifiers]
    call changeUmlMethodVisibility(affectedEObject, newValue)
}*/
//TODO
reaction JavaMethodMadePrivate {
    after element java::Private created and inserted in java::ClassMethod[annotationsAndModifiers]
    call changeUmlMethodVisibility(affectedEObject, newValue)
}

reaction JavaMethodMadeProtected {
    after element java::Protected created and inserted in java::ClassMethod[annotationsAndModifiers]
    call changeUmlMethodVisibility(affectedEObject, newValue)
}

reaction JavaMethodMadePackagePrivate {
    after element java::Modifier deleted and removed from java::ClassMethod[annotationsAndModifiers]
    with oldValue instanceof Private
    || oldValue instanceof Public
    || oldValue instanceof Protected
    call changeUmlMethodVisibility(affectedEObject, null)
}

routine changeUmlMethodVisibility( java::ClassMethod jMeth, java::Modifier mod) {
    match {
        val uMeth = retrieve uml::Operation corresponding to jMeth
    }
    action {
        update uMeth {
            uMeth.visibility = getUmlVisibilityKind(mod);
        }
    }
}

//Java-Klasse ist automatisch abstrakt, sobald sie eine abstrakte Methode erh√§lt
reaction JavaMethodMadeAbstract {
    after element java::Abstract created and inserted in java::ClassMethod[annotationsAndModifiers]
    call  {
        setUmlMethodAbstract(affectedEObject, 1)
        setUmlClassAbstract(affectedEObject.eContainer as org.emftext.language.java.classifiers.Class, 1)
    }
}

reaction JavaMethodMadeNonAbstract {
    after element java::Abstract deleted and removed from java::ClassMethod[annotationsAndModifiers]
    call setUmlMethodAbstract(affectedEObject, 0)
}

routine setUmlMethodAbstract(java::ClassMethod jMeth, Int isAbstract) {
    match {
        val uMeth = retrieve uml::Operation corresponding to jMeth
    }
    action {
        update uMeth {
            if (isAbstract == 1){
                uMeth.isAbstract = true;
            } else if (isAbstract == 0) {
                uMeth.isAbstract = false;
            } else {
                throw new IllegalArgumentException("Invalid isAbstract Value: " + isAbstract);
            }
        }
    }
}

reaction JavaMethodMadeStatic {
    after element java::Static created and inserted in java::ClassMethod[annotationsAndModifiers]
    call setUmlMethodStatic(affectedEObject, 1)
}

reaction JavaMethodMadeNonStatic {
    after element java::Static deleted and removed from java::ClassMethod[annotationsAndModifiers]
    call setUmlMethodStatic(affectedEObject, 0)
}

routine setUmlMethodStatic(java::ClassMethod jMeth, Int isStatic) {
    match {
        val uMeth = retrieve uml::Operation corresponding to jMeth
    }
    action {
        update uMeth {
            if (isStatic == 1) {
                uMeth.isStatic = true;
            } else if (isStatic == 0) {
                uMeth.isStatic = false;
            } else {
                throw new IllegalArgumentException("Invalid isStatic Value: " + isStatic);
            }
        }
    }
}

reaction JavaParameterCreated {
    after element java::OrdinaryParameter created and inserted in java::Method[parameters]
    call createUmlParameter(affectedEObject, newValue)
}

routine createUmlParameter(java::Method jMeth, java::OrdinaryParameter jParam) {
    match {
        val uMeth = retrieve uml::Operation corresponding to jMeth
        val customType = retrieve optional uml::Class corresponding to getClassifierfromTypeRef(jParam.typeReference)
    }
    action {
        val uParam = create uml::Parameter and initialize {
            if (jParam.name != null) {
                uParam.name = jParam.name;
            } else {
                uParam.name = "DefaultUmlParameterName";
            }
            if (jParam.typeReference != null) {
                uParam.type = getUmlType(jParam.typeReference, customType, getUmlModel(correspondenceModel))
            }
        }
        add correspondence between uParam and jParam
        update uMeth {
            uMeth.ownedParameters += uParam
        }
    }
}

reaction JavaParameterRenamed {
    after attribute replaced at java::OrdinaryParameter[name]
    call renameJavaParameter(affectedEObject)
}

routine renameJavaParameter(java::OrdinaryParameter jParam) {
    match {
        val uParam = retrieve uml::Parameter corresponding to jParam
    }
    action {
        update uParam {
            uParam.name = jParam.name;
        }
    }
}

reaction JavaParameterDeleted {
    after element java::OrdinaryParameter deleted and removed from java::Method[parameters]
    call deleteJavaParameter(oldValue)
}

routine deleteJavaParameter(java::OrdinaryParameter jParam) {
    match {
        val uParam = retrieve uml::Parameter corresponding to jParam
    }
    action{
        delete uParam         
    }
}

reaction JavaParameterTypeChanged {
    after element java::TypeReference replaced at java::OrdinaryParameter[typeReference]
    call changeUmlParameterType(affectedEObject, newValue)
}

routine changeUmlParameterType(java::OrdinaryParameter jParam, java::TypeReference jType) {
    match {
        val uParam = retrieve uml::Parameter corresponding to jParam
        val customType = retrieve optional uml::Class corresponding to getClassifierfromTypeRef(jType)
    }
    action {
        update uParam {
            uParam.type = getUmlType(jType, customType, getUmlModel(correspondenceModel));
        }
    }
}

reaction JavaReturnTypeChanged {
    after element java::TypeReference replaced at java::Method[typeReference]
    call changeUmlReturnType(affectedEObject, newValue)
}

routine changeUmlReturnType(java::Method jMeth, java::TypeReference jType) {
    match {
        val uMeth = retrieve uml::Operation corresponding to jMeth
        val customType = retrieve optional uml::Class corresponding to getClassifierfromTypeRef(jType)
    }
     action {
         update uMeth {
             uMeth.type = getUmlType(jType, customType, getUmlModel(correspondenceModel))
         }
     }
}

reaction JavaAttributeCreated {
    after element java::Field created and inserted in java::Class[members]
    call {
        System.out.println("JavaAttr Created Reaction")
        createUmlAttribute(affectedEObject, newValue)
        
        }
}

routine createUmlAttribute(java::Class jClass, java::Field jAttr) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
        val uType = retrieve optional uml::Classifier corresponding to jAttr.typeReference.target
    }
    action {
        val uAttr = create uml::Property and initialize {
            if (jAttr.name != null) {
                uAttr.name = jAttr.name;
            } else {
                uAttr.name = "DefaultUmlAttributeName";
            }
            if (uType != null) {
                uAttr.type = uType;
            }
        }
        add correspondence between uAttr and jAttr
        update uClass {
            uClass.ownedAttributes += uAttr;
        }
    }
}

reaction JavaAttributeRenamed {
    after attribute replaced at java::Field[name]
    call renameUmlAttribute(affectedEObject)
}

routine renameUmlAttribute(java::Field jAttr) {
    match {
        val uAttr = retrieve uml::Property corresponding to jAttr
    }
    action {
        update uAttr {
            uAttr.name = jAttr.name;
        }
    }
}

reaction JavaAttributeDeleted {
    after element java::Field deleted and removed from java::Class[members]
    call deleteUmlAttribute(oldValue)
}

routine deleteUmlAttribute(java::Field jAttr) {
    match {
        val uAttr = retrieve uml::Property corresponding to jAttr
    }
    action {
        delete uAttr
    }
}

reaction JavaAttributeTypeChanged {
    after element java::TypeReference replaced at java::Field[typeReference]
    call {
        System.out.println("Attribute Changed Reaction")
        changeUmlAttributeType(affectedEObject, newValue)
        
        }
}

routine changeUmlAttributeType(java::Field jAttr, java::TypeReference jType) {
    match {
        val uAttr = retrieve uml::Property corresponding to jAttr
        val customType = retrieve optional uml::Class corresponding to getClassifierfromTypeRef(jType)
    }
    action {
        update uAttr {
            uAttr.type = getUmlType(jType, customType, getUmlModel(correspondenceModel))
        }
        
    }
}
/* 
reaction JavaAttributeMadePublic {
    after element java::Public created and inserted in java::Field[annotationsAndModifiers]
    call changeUmlAttributeVisibility(affectedEObject, newValue)
}*/
// TODO 
reaction JavaAttributeMadePrivate {
    after element java::Private created and inserted in java::Field[annotationsAndModifiers]
    call changeUmlAttributeVisibility(affectedEObject, newValue)
}

reaction JavaAttributeMadeProtected {
    after element java::Protected created and inserted in java::Field[annotationsAndModifiers]
    call changeUmlAttributeVisibility(affectedEObject, newValue)
}

reaction JavaAttributeMadePackagePrivate {
    after element java::Modifier deleted and removed from java::Field[annotationsAndModifiers]
    with oldValue instanceof Private
    || oldValue instanceof Public
    || oldValue instanceof Protected
    call changeUmlAttributeVisibility(affectedEObject, null)
}

routine changeUmlAttributeVisibility(java::Field jAttr, java::Modifier mod) {
    match {
       val uAttr = retrieve uml::Property corresponding to jAttr 
    }
    action {
        update uAttr {
            uAttr.visibility = getUmlVisibilityKind(mod);
        }
    }
}

reaction JavaAttributeMadeStatic {
    after element java::Static created and inserted in java::Field[annotationsAndModifiers]
    call setUmlAttributeStatic(affectedEObject, 1)
}

reaction JavaAttributeMadeNonStatic {
    after element java::Static deleted and removed from java::Field[annotationsAndModifiers]
    call setUmlAttributeStatic(affectedEObject, 0)
}

routine setUmlAttributeStatic(java::Field jAttr, Int isStatic) {
    match {
        val uAttr = retrieve uml::Property corresponding to jAttr
    }
    action {
        update uAttr {
            if (isStatic == 1) {
                uAttr.isStatic = true;
            } else if (isStatic == 0) {
                uAttr.isStatic = false;
            } else {
                throw new IllegalArgumentException("Invalid isStatic value: " + isStatic);
            }
        }
    }
}

reaction JavaAttributeMadeFinal {
    after element java::Final created and inserted in java::Field[annotationsAndModifiers]
    call setUmlAttributeFinal(affectedEObject, 1)
}

routine setUmlAttributeFinal(java::Field jAttr, Int isFinal) {
    match {
        val uAttr = retrieve uml::Property corresponding to jAttr 
    }
    action {
        update uAttr {
            if (isFinal == 1) {
                uAttr.isReadOnly = true;
            } else if (isFinal == 0) {
                uAttr.isReadOnly = false;
            } else {
                throw new IllegalArgumentException("Invalid isFinal value: " + isFinal);
            }
        }
    }
}

reaction Logreaction {
    after any change
    call {
        PropertyConfigurator.configure("log4j.properties")
    }
}