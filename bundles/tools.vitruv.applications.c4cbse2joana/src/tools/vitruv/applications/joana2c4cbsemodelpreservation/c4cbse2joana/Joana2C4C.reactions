import edu.kit.ipd.sdq.metamodels.confidentiality4cbse.Confidentiality4cbsePackage
import edu.kit.ipd.sdq.metamodels.confidentiality4cbse.ConfidentialitySpecification
import edu.kit.ipd.sdq.metamodels.confidentiality4cbse.information.ParameterInformation
import edu.kit.ipd.sdq.metamodels.confidentiality4cbse.repository.SignatureInformationFlow
import edu.kit.ipd.sdq.metamodels.joana.EntryPoint
import edu.kit.ipd.sdq.metamodels.joana.FlowRelation
import edu.kit.ipd.sdq.metamodels.joana.JOANARoot
import edu.kit.ipd.sdq.metamodels.joana.SecurityLevel
import edu.kit.ipd.sdq.metamodels.joana.Sink
import java.util.ArrayList
import java.util.HashSet
import java.util.List
import org.eclipse.emf.common.util.BasicEList
import tools.mdsd.jamopp.model.java.classifiers.Interface
import tools.mdsd.jamopp.model.java.containers.ContainersPackage
import tools.mdsd.jamopp.model.java.members.InterfaceMethod
import org.eclipse.emf.ecore.util.EcoreUtil

import "edu.kit.ipd.sdq.metamodels.joana" as joana
import "edu.kit.ipd.sdq.metamodels.confidentiality4cbse" as c4c
import "https://mdsd.tools/jamopp/6.0.0/java" as java
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: joana2c4c
in reaction to changes in joana
execute actions in c4c


/*
 * Creates a ConfidentialitySpecification, if a JOANARoot is created
 */
reaction JoanaRootCreated {
	after element joana::JOANARoot created
	call {
		searchForC4CRoot(affectedEObject)
	}
}

routine searchForC4CRoot(joana::JOANARoot joanaRoot){
	match{
		require absence of c4c::ConfidentialitySpecification corresponding to joanaRoot
		val c4cRoot = retrieve optional c4c::ConfidentialitySpecification corresponding to ContainersPackage.Literals.PACKAGE
	}
	update{
		if(c4cRoot.present){
			addCorrespondenceBetween(c4cRoot.get, joanaRoot)
		} else {
			val c4cRoots = joanaRoot.eResource.allContents.toList.filter(ConfidentialitySpecification).toList
			if(c4cRoots.empty){
				createC4CRoot(joanaRoot)
			} else {
				addCorrespondenceBetween(joanaRoot, c4cRoots.get(0))
			}
		}
	}
}

routine createC4CRoot(joana::JOANARoot joanaRoot){
	create{
		val c4cRoot = new c4c::ConfidentialitySpecification
	}
	update{
		c4cRoot.entityName = "C4CRoot"
		persistProjectRelative(joanaRoot, c4cRoot, "model/" + c4cRoot.entityName + ".c4cRoot")
		addCorrespondenceBetween(joanaRoot, c4cRoot)
		addCorrespondenceBetween(c4cRoot, ContainersPackage.Literals.PACKAGE)
	}
}
/*
 * Checks whether there is already a DataSet with this name.
 * Checks whether there is already a SecurityLevel with this name.
 * Creates a DataSet and composite SecurityLevels if needed.
 */
reaction SecurityLevelCreated{
	after element joana::SecurityLevel created
	call {
		createDataSetFromSecurityLevel(affectedEObject)
		updateLevelsOfEntryPoints()
	}
}

routine updateLevelsOfEntryPoints(){
	match{
		val joanaRoot = retrieve joana::JOANARoot corresponding to ContainersPackage.Literals.PACKAGE
	}
	update{
		for(flow : joanaRoot.flowspecification){
			addLevelsToEntryPoint(flow.entrypoint)
		}
	}
}

/*
 * Deletes the corresponding DataSet and all composite levels with this DataSet, if the original level is not a composite level itself.
 * If the deleted level is a composite level, produces a warning.
 */
reaction SecurityLevelDeleted{
	after element joana::SecurityLevel removed from joana::JOANARoot[securitylevel]
	call {
		deleteDataSetFromSecurityLevel(oldValue, affectedEObject)
	}
}


routine createDataSetFromSecurityLevel(joana::SecurityLevel newLevel) {
	match {
		val uC4CRoot = retrieve c4c::ConfidentialitySpecification corresponding to newLevel.eContainer
		require absence of c4c::DataSet corresponding to newLevel
	}
	create {
		val dataSet = new c4c::DataSet
	}
	update {
		dataSet.entityName = newLevel.name
		uC4CRoot.dataIdentifier.add(dataSet)
		addCorrespondenceBetween(newLevel, dataSet)
		createCompositeSecurityLevels(newLevel, dataSet)
	}
}

routine addLevelToLattice(joana::SecurityLevel newLevel, joana::JOANARoot joanaRoot){
	update{
		var oldLattice = new BasicEList<FlowRelation>
		oldLattice.addAll(joanaRoot.lattice.flowrelation)
		val copyLattice = joanaRoot.lattice.flowrelation.clone
		if (!joanaRoot.lattice.flowrelation.empty){
			for(curFlow : copyLattice){
				oldLattice.remove(curFlow)
				var isLeaf = true
				for(testFlow : copyLattice){
					if(testFlow.^from.iterator.next.name.matches(curFlow.^to.iterator.next.name)){
						isLeaf = false
					}
				}
				var SecurityLevel newFrom = null
				var SecurityLevel newTo = null
				for(level : joanaRoot.securitylevel){
					if(level.name.matches(curFlow.^from.get(0).name + newLevel.name) || level.name.matches(newLevel.name + curFlow.^from.get(0).name)){
						newFrom = level
					}
					if(level.name.matches(curFlow.^to.get(0).name + newLevel.name) || level.name.matches(newLevel.name + curFlow.^to.get(0).name)){
						newTo = level
					}
				}
				if(newFrom !== null && newTo !== null){
					createFlowRelation(newFrom, newTo, joanaRoot.lattice)
					createFlowRelation(newTo, curFlow.^to.iterator.next, joanaRoot.lattice)
					if(isLeaf){
						createFlowRelation(newTo, newLevel, joanaRoot.lattice)
					} else {
						createFlowRelation(newFrom, curFlow.^from.iterator.next, joanaRoot.lattice)
					}
				}
				
			} 
		}
		//Create a Lattice, when there are two basic security levels.
		if(joanaRoot.lattice.flowrelation.empty && joanaRoot.securitylevel.size >= 3){
			var longestString = ""
			var SecurityLevel compLevel = null
			for(level : joanaRoot.securitylevel){
				if(level.name.length > longestString.length){
					longestString = level.name
					compLevel = level
				}
			}
			for(level : joanaRoot.securitylevel){
				if(!level.name.matches(longestString)){
					createFlowRelation(compLevel, level, joanaRoot.lattice)
				}
			}
		}
		removeDuplicates(joanaRoot.lattice)
		updateLatticeOfEntryPoints(joanaRoot, joanaRoot.lattice)
	}
}

routine updateLatticeOfEntryPoints(joana::JOANARoot joanaRoot, joana::Lattice newLattice){
	update{
		for(flowSpec : joanaRoot.flowspecification){
				flowSpec.entrypoint.lattice = newLattice
		}
	}
}

routine removeDuplicates(joana::Lattice lattice){
	update{
		var sortingSet = new HashSet
		for(flow : lattice.flowrelation){
			if(!sortingSet.add(flow.^from.iterator.next.name + "." + flow.^to.iterator.next.name)){
				lattice.flowrelation.remove(flow)
			}
		}
	}
}

routine createFlowRelation(joana::SecurityLevel fromLev, joana::SecurityLevel toLev, joana::Lattice lattice){
	create{
		val newFlow = new joana::FlowRelation
	}
	update{
		newFlow.^from.add(fromLev)
		newFlow.^to.add(toLev)
		lattice.flowrelation.add(newFlow)
	}
}

routine createCompositeSecurityLevels(joana::SecurityLevel newLevel, c4c::DataSet set){
	update{
		val cont = newLevel.eContainer as JOANARoot
		val secLevs = cont.securitylevel
		val List<SecurityLevel> dummyList = new ArrayList<SecurityLevel>
		for(level : secLevs){
			if(!level.name.matches(newLevel.name)){
				dummyList.add(level)
			}
		}
		for(level : dummyList){
			containsCorrespondenceToSet(set, level, level.name + newLevel.name, newLevel)
		}
		addLevelToLattice(newLevel, newLevel.eContainer as JOANARoot)
	}
}

routine containsCorrespondenceToSet(c4c::DataSet set, joana::SecurityLevel level, String name, joana::SecurityLevel originLevel){
	match{
		val corSets = retrieve many c4c::DataSet corresponding to level
	}
	update{
		var boolean flag = false
		if(corSets.size > 0){
			for(curSet : corSets){
				if(set.entityName.matches(curSet.entityName)){
					flag = true
				}
			}
			if(!flag){
				createSecurityLevel(set, name, level, originLevel)
			}
		}
		
	}
}

routine createSecurityLevel(c4c::DataSet set, String name, joana::SecurityLevel firstLevel, joana::SecurityLevel secondLevel){
	create{
		val newLevel = new joana::SecurityLevel
	}
	update{
		newLevel.name = name
		addCorrespondenceBetween(newLevel, set)
		(firstLevel.eContainer as JOANARoot).securitylevel.add(newLevel)
		addCorrespondecesToCompositeLevels(firstLevel, secondLevel, newLevel)
	}
}

routine addCorrespondecesToCompositeLevels(joana::SecurityLevel firstLevel, joana::SecurityLevel secondLevel, joana::SecurityLevel newLevel){
	match{
		val sets = retrieve many c4c::DataSet corresponding to firstLevel
		val originSets = retrieve many c4c::DataSet corresponding to secondLevel
	}
	update{
		for(set : sets){
			addCorrespondenceBetween(set, newLevel)
		}
		for(set : originSets){
			addCorrespondenceBetween(set, newLevel)
		}
	}
}

routine deleteDataSetFromSecurityLevel(joana::SecurityLevel oldLevel, joana::JOANARoot joanaRoot) {
	match {
		val correspondingSets = retrieve many c4c::DataSet corresponding to oldLevel
		val ignoreSets = retrieve many c4c::DataSet corresponding to oldLevel tagged "composite"
	}
	update {
		var newSet = new HashSet
		newSet.addAll(correspondingSets)
		newSet.removeAll(ignoreSets)
		if(newSet.empty){
			removeSingleLevelFromLattice(oldLevel, joanaRoot.lattice)
		} else if(newSet.length == 1){
			removeLevelFromLattice(newSet.iterator.next, joanaRoot.lattice)
			EcoreUtil.delete(newSet.get(0))
			removeCorrespondenceBetween(oldLevel, newSet.get(0))
			removeCompositeSecurityLevels(newSet.get(0))
		} else {
			removeCompositeLevelFromLattice(oldLevel, joanaRoot.lattice)
		}
	}
}

routine removeSingleLevelFromLattice(joana::SecurityLevel level, joana::Lattice lattice){
	update{
		var toRemove = new ArrayList
		for(flow : lattice.flowrelation){
			if(flow.^from.empty || flow.^to.empty){
				toRemove.add(flow)
			} else if(flow.^from.contains(level) || flow.^to.contains(level)){
				toRemove.add(flow)
			}
		}
		lattice.flowrelation.remove(toRemove)
		updateLatticeOfEntryPoints(lattice.eContainer as JOANARoot, lattice)
	}
}

routine removeLevelFromLattice(c4c::DataSet oldDataSet, joana::Lattice lattice){
	match{
		val levels = retrieve many joana::SecurityLevel corresponding to oldDataSet
	}
	update{
		var toRemove = new ArrayList
		for(flow : lattice.flowrelation){
			if(flow.^from.empty || flow.^to.empty){
				toRemove.add(flow)
			} else if(levels.contains(flow.^from.iterator.next) || levels.contains(flow.^to.iterator.next)){
				toRemove.add(flow)
			}
			
		}
		lattice.flowrelation.remove(toRemove)
		updateLatticeOfEntryPoints(lattice.eContainer as JOANARoot, lattice)
	}
}

routine removeCompositeLevelFromLattice(joana::SecurityLevel oldLevel, joana::Lattice lattice){
	update{
		var fromList = new ArrayList<SecurityLevel>
		var toList = new ArrayList<SecurityLevel>
		for(flow : lattice.flowrelation){
			if(flow.^from.empty){
				toList.add(flow.^to.iterator.next)
			} else if(flow.^to.empty){
				fromList.add(flow.^from.iterator.next)
			} else {
				if(flow.^from.iterator.next.name.matches(oldLevel.name)){
					fromList.add(flow.^to.iterator.next)
					lattice.flowrelation.remove(flow)
				}
				if(flow.^to.iterator.next.name.matches(oldLevel.name)){
					toList.add(flow.^from.iterator.next)
					lattice.flowrelation.remove(flow)
				}
			}
			
		}
		for(fromLev : fromList){
			for(toLev : toList){
				createFlowRelation(fromLev, toLev, lattice)
			}
		}
		updateLatticeOfEntryPoints(lattice.eContainer as JOANARoot, lattice)
	}
}

routine removeCompositeSecurityLevels(c4c::DataSet correspondingSet){
	match{
		val correspondingLevels = retrieve many joana::SecurityLevel corresponding to correspondingSet
	}
	update{
		for(level : correspondingLevels){
			removeCorrespondencesFromLevel(level)
			EcoreUtil.delete(level)
		}
	}
}

routine removeCorrespondencesFromLevel(joana::SecurityLevel level){
	match{
		val correspondingSets = retrieve many c4c::DataSet corresponding to level
	}
	update{
		for(set : correspondingSets){
			removeCorrespondenceBetween(set, level)
		}
	}
}

/*
 * Checks whether a PDP containing the corresponding securitylevels exists.
 * Creates a corresponding PDP if needed.
 * Creates matching Source and Entry Point if needed.
 */
reaction SinkCreated{
	after element joana::Sink created
	call{
		getOpSigFromMethod(affectedEObject, affectedEObject.annotatedMethod as InterfaceMethod)
		checkForFlowSpec(affectedEObject)
	}
}

routine checkForFlowSpec(joana::Annotation anno){
	match{
		val joanaRoot = retrieve joana::JOANARoot corresponding to ContainersPackage.Literals.PACKAGE
	}
	update{
		for(flowSpec : joanaRoot.flowspecification){
			if(flowSpec.entrypoint !== null && !flowSpec.entrypoint.tag.empty && anno.tag.contains(flowSpec.entrypoint.tag.get(0))){
				flowSpec.annotation.add(anno)
			}
		}
	}
}

routine getOpSigFromMethod(joana::Annotation anno, java::InterfaceMethod method){
	match{
		require absence of c4c::ParameterInformation corresponding to anno
		val opSig = retrieve pcm::OperationSignature corresponding to method
		val c4cRoot = retrieve c4c::ConfidentialitySpecification corresponding to anno.eContainer
		val pcmPara = retrieve optional pcm::Parameter corresponding to anno.annotatedParameter
	}
	update{
		val ifList = c4cRoot.informationFlows
		var flowFound = false
		for(flow : ifList){
			if((flow as SignatureInformationFlow).appliedTo.entityName.matches(opSig.entityName)){
				flowFound = true
				var matchingInfoFound = false
				for(info : (flow as SignatureInformationFlow).information){
					for(set : info.dataTargets){
						if(set.entityName.matches(anno.securitylevel.get(0).name)){
							if(pcmPara.present && (info as ParameterInformation).appliedTo !== null){
								if(pcmPara.get.parameterName.matches((info as ParameterInformation).appliedTo.parameterName)){
									addCorrespondenceBetween(anno, info)
									matchingInfoFound = true
								}
							} else {
								if(anno.annotatedParameter === null){
									addCorrespondenceBetween(anno, info)
									matchingInfoFound = true
								}
							}
						}
					}
				}
				if(!matchingInfoFound){
					createInfo(anno, method, flow as SignatureInformationFlow)
				}
			}
		}
		if(!flowFound){
			createInfoAndIF(anno, method, opSig)
		}
	}
}

routine createInfo(joana::Annotation anno, java::Method method, c4c::SignatureInformationFlow flow){
	match{
		val para = retrieve optional pcm::Parameter corresponding to anno.annotatedParameter
	}
	create{
		val info = new c4c::ParameterInformation
	}
	update{
		for(level : anno.securitylevel){
			addDataPairsToInfo(info, level)
		}
		if(para.present && para.get !== null){
			info.appliedTo = para.get
		}
		addCorrespondenceBetween(anno, info)
		flow.information.add(info)
	}
}

routine createInfoAndIF(joana::Annotation anno, java::Method method, pcm::OperationSignature opSig){
	match{
		val para = retrieve optional pcm::Parameter corresponding to anno.annotatedParameter
	}
	create{
		val info = new c4c::ParameterInformation
		val flow = new c4c::SignatureInformationFlow
	}
	update{
		for(level : anno.securitylevel){
			addDataPairsToInfo(info, level)
		}
		if(para.present && para.get !== null){
			info.appliedTo = para.get
		}
		flow.appliedTo = opSig
		addCorrespondenceBetween(anno, info)
		val joanaRoot = anno.eContainer as JOANARoot
		persistFlow(flow, joanaRoot)
		flow.information.add(info)
	}
}

routine persistFlow(c4c::SignatureInformationFlow flow, joana::JOANARoot joanaRoot){
	match{
		val c4cRoot = retrieve c4c::ConfidentialitySpecification corresponding to joanaRoot
	}
	update{
		c4cRoot.informationFlows.add(flow)
	}
}

routine addDataPairsToInfo(c4c::ParameterInformation info, joana::SecurityLevel level){
	match{
		val dataSets = retrieve many c4c::DataSet corresponding to level
	}
	update{
		for(set : dataSets){
			info.dataTargets.add(set)
		}
	}
}

routine checkPointIFCorrespondence(joana::EntryPoint point, c4c::SignatureInformationFlow flow){
	match{
		val corFlows = retrieve many c4c::SignatureInformationFlow corresponding to point
	}
	update{
		var corFound = false
		for(corFlow : corFlows){
			if(flow.entityName.matches(corFlow.entityName)){
				corFound = true
			}
		}
		if(!corFound){
			addCorrespondenceBetween(point, flow)
		}
	}
}

routine updateSinksAdd(java::Method method){
	match{
		val joanaRoot = retrieve joana::JOANARoot corresponding to ContainersPackage.Literals.PACKAGE
	}
	update{
		val allSinks = joanaRoot.eResource().allContents.toList.iterator().filter[it instanceof Sink].toList()
		for(sink : allSinks){
			if((sink as Sink).annotatedMethod !== null && !(sink as Sink).annotatedMethod.name.matches(method.name)){
				(sink as Sink).tag.add((method.eContainer as Interface).name + "." + method.name)
			}
		}
	}
}

routine updateSinksRemove(java::Method method){
	match{
		val joanaRoot = retrieve joana::JOANARoot corresponding to ContainersPackage.Literals.PACKAGE
	}
	update{
		val allSinks = joanaRoot.eResource().allContents.toList.iterator().filter[it instanceof Sink].toList()
		for(sink : allSinks){
			if((sink as Sink).annotatedMethod !== null && !(sink as Sink).annotatedMethod.name.matches(method.name)){
				(sink as Sink).tag.remove((method.eContainer as Interface).name + "." + method.name)
			}
		}
	}
}


/*
 * Checks whether a ParameterInformation containing the corresponding securitylevels exists.
 * Creates a corresponding ParameterInformation if needed.
 * Creates matching Sink and Entry Point if needed.
 */
reaction SourceCreated{
	after element joana::Source created
	call{
		getOpSigFromMethod(affectedEObject, affectedEObject.annotatedMethod as InterfaceMethod)
		checkForFlowSpec(affectedEObject)
	}
}

/*
 * Checks whether a SignatureInformationFLow corresponding to the EntryPoint exists.
 * Creates a corresponding SignatureInformationFlow if needed.
 * Creates matching Sink and Source if needed.
 */
reaction EntryPointCreated{
	after element joana::EntryPoint created
	call{
		getOpSigFromMethodForEntryPoints(affectedEObject, affectedEObject.annotatedMethod)
		updateSinksAdd(affectedEObject.annotatedMethod)
	}
}

routine addLevelsToEntryPoint(joana::EntryPoint point){
	match{
		val joanaRoot = retrieve joana::JOANARoot corresponding to ContainersPackage.Literals.PACKAGE
	}
	update{
		point.securitylevels.clear
		point.securitylevels.addAll(joanaRoot.securitylevel)
	}
}

//Checks whether there is an InformationFlow Stereotype at the OperationSignature. If not, creates a new IF and a new PDP. If so, checks whether the IF has a matching DataSet. If not, creates one. If so, does nothing.
routine getOpSigFromMethodForEntryPoints(joana::EntryPoint point, java::Method method){
	match{
		require absence of c4c::SignatureInformationFlow corresponding to point
		val opSig = retrieve pcm::OperationSignature corresponding to method
		val c4cRoot = retrieve c4c::ConfidentialitySpecification corresponding to point.eContainer.eContainer
	}
	update{
		val ifList = c4cRoot.informationFlows
		var flowFound = false
		for(flow : ifList){
			if((flow as SignatureInformationFlow).appliedTo.entityName.matches(opSig.entityName)){
				flowFound = true
			}
		}
		if(!flowFound){
			createInfoAndIFForEntryPoints(point, method, opSig)
		}
	}
}

routine createInfoAndIFForEntryPoints(joana::EntryPoint point, java::Method method, pcm::OperationSignature opSig){
	create{
		val flow = new c4c::SignatureInformationFlow
	}
	update{
		addCorrespondenceBetween(point, flow)
		val joanaRoot = point.eContainer.eContainer as JOANARoot
		persistFlow(flow, joanaRoot)
	}
}

/*
 * Deletes EntryPoint and Source at the same Method.
 * Deletes corresponding ParameterInformation.
 */
reaction SinkDeleted{
	after element joana::Sink deleted
	call{
		deleteInfo(affectedEObject)
		removeFromFlowSpec(affectedEObject)
	}
}

routine removeFromFlowSpec(joana::Annotation anno){
	match{
		val joanaRoot = retrieve joana::JOANARoot corresponding to ContainersPackage.Literals.PACKAGE
	}
	update{
		if(anno.annotatedMethod !== null){
			for(flowSpec : joanaRoot.flowspecification){
				if(flowSpec.annotation.contains(anno)){
					flowSpec.annotation.remove(anno)
				}
			}
		}
	}
}

routine deleteInfo(joana::Annotation anno){
	match{
		val info = retrieve c4c::ParameterInformation corresponding to anno
	}
	update{
		removeCorrespondenceBetween(anno, info)
		EcoreUtil.delete(info)
	}
}

/*
 * Deletes the corresponding ParameterInformation and the Sink and EntryPoint of the set
 */
reaction SourceDeleted{
	after element joana::Source deleted
	call{
		deleteInfo(affectedEObject)
		removeFromFlowSpec(affectedEObject)
	}
}

/*
 * Deletes the corresponding SignatureInformationFlow and the Sink and Source of the point. 
 * Also removes all securitylevels which are not used by any other EntryPoint.
 */
reaction EntryPointDeleted{
	after element joana::EntryPoint deleted
	call{
		searchSoleSecurityLevels(affectedEObject)
		retrieveFlowFromEP(affectedEObject)
		updateSinksRemove(affectedEObject.annotatedMethod)
	}
}

routine retrieveFlowFromEP(joana::EntryPoint point){
	match{
		val flow = retrieve  c4c::SignatureInformationFlow corresponding to point
	}
	update{
		for(info : flow.information){
			deleteAnnosToEP(info as ParameterInformation)
		}
		removeCorrespondenceBetween(point, flow)
		EcoreUtil.delete(flow)
	}
}

routine deleteAnnosToEP(c4c::ParameterInformation info){
	match{
		val sink = retrieve optional joana::Sink corresponding to info
		val source = retrieve optional joana::Source corresponding to info
	}
	update{
		if(sink.present){
			removeCorrespondenceBetween(info, sink.get)
			EcoreUtil.delete(sink.get)
		}
		if(source.present){
			removeCorrespondenceBetween(info, source.get)
			EcoreUtil.delete(source.get)
		}
	}
}

routine searchSoleSecurityLevels(joana::EntryPoint point){
	update{
		for(level : point.securitylevels){
			removeSoleSecurityLevels(level)
		}
	}
}

routine removeSoleSecurityLevels(joana::SecurityLevel level){
	match{
		val conSets = retrieve many c4c::DataSet corresponding to level
	}
	update {
		if(conSets.size == 1){
			val allEntryPoints = level.eResource().allContents.toList.iterator().filter(EntryPoint).toList()
			for(point : allEntryPoints){
				var found = false
				for(curLevel :point.securitylevels){
					if(curLevel.name.matches(level.name)){
						found = true
					}
				}
				if(!found){
					EcoreUtil.delete(level)
				}
			}
		}
	}
}

/*
 * Adds a DataSet to the corresponding ParameterInformation, if a SecurityLevel is added to a sink.
 */
reaction LevelAddedToSink{
	after element joana::SecurityLevel inserted in joana::Sink[securitylevel]
	call{
		addDataSetToInfo(affectedEObject, newValue)
	}
}

/*
 * Removes the old DataSets of the corresponding ParameterInformation and adds the ones corresponding to the new level.
 * The test for equality of the sets is necessary to prevent a loop from the transitive execution.
 */
reaction LevelAddedToSource{
	after element joana::SecurityLevel inserted in joana::Source[securitylevel]
	call{
		addDataSetToInfo(affectedEObject, newValue)
	}
}

routine addDataSetToInfo(joana::Annotation anno, joana::SecurityLevel level){
	match{
		val info = retrieve c4c::ParameterInformation corresponding to anno
		val sets = retrieve many c4c::DataSet corresponding to level
	}
	update{
		if(anno.securitylevel.size > 1){
			anno.securitylevel.clear
			anno.securitylevel.add(level)
		}
		var sameSet = true
		for(set : sets){
			var alreadyContained = false
			for(searchedSet : info.dataTargets){
				if(searchedSet.entityName.matches(set.entityName)){
					alreadyContained = true
				}
			}
			if(!alreadyContained){
				sameSet = false
			}
		}
		if(!sameSet){
			info.dataTargets.clear
			info.dataTargets.addAll(sets)
		}
	}
}

/*
 * After a security level is removed from a source, removes the corresponding datasets from the ParameterInformation corresponding to the source. 
 * If the DataSets of the ParameterInformation dont match with the DataSets corresponding with the level, does nothing.
 * If the source has no other securitylevels, removes it.
 */
reaction LevelRemovedFromSource{
	after element joana::SecurityLevel removed from joana::Source[securitylevel]
	call{
		removeSetFromAnno(oldValue, affectedEObject)
	}
}

routine removeSetFromAnno(joana::SecurityLevel level, joana::Annotation anno){
	match{
		val sets = retrieve many c4c::DataSet corresponding to level
		val info = retrieve c4c::ParameterInformation corresponding to anno
	}
	update{
		var sameSet = true
		for(set : sets){
			var alreadyContained = false
			for(searchedSet : info.dataTargets){
				if(searchedSet.entityName.matches(set.entityName)){
					alreadyContained = true
				}
			}
			if(!alreadyContained){
				sameSet = false
			}
		}
		if(sameSet && !sets.empty){
			info.dataTargets.clear
		}
		if(anno.securitylevel.empty){
			EcoreUtil.delete(anno)
		}
	}
}


/*
 * After a security level is removed from a sink, removes the corresponding datasets from the ParameterInformation corresponding to the sink. 
 * If the DataSets of the ParameterInformation dont match with the DataSets corresponding with the level, does nothing.
 * If the sink has no other securitylevels, removes it.
 */
reaction LevelRemovedFromSink{
	after element joana::SecurityLevel removed from joana::Sink[securitylevel]
	call{
		removeSetFromAnno(oldValue, affectedEObject)
	}
}

/*
 * Changes the Information corresponding to the sink to the flow annotating the new method.
 */
reaction MethodOfSinkChanged{
	after element java::Method replaced at joana::Sink[annotatedMethod]
	call{
		changeMethodOfAnno(affectedEObject, newValue)
	}
}

/*
 * Changes the Information corresponding to the source to the flow annotating the new method.
 */
reaction MethodOfSourceChanged{
	after element java::Method replaced at joana::Source[annotatedMethod]
	call{
		changeMethodOfAnno(affectedEObject, newValue)
	}
}

routine changeMethodOfAnno(joana::Annotation anno, java::Method method){
	match{
		val opSig = retrieve pcm::OperationSignature corresponding to method
		val info = retrieve c4c::ParameterInformation corresponding to anno
		val c4cRoot = retrieve c4c::ConfidentialitySpecification corresponding to anno.eContainer
	}
	update{
		if(info.eContainer !== null) {
			if(!(info.eContainer as SignatureInformationFlow).appliedTo.entityName.matches(opSig.entityName)){
				addCorrespondenceBetween(info, Confidentiality4cbsePackage.Literals.CONFIDENTIALITY_SPECIFICATION)
				(info.eContainer as SignatureInformationFlow).information.remove(info)
				val allFlows = c4cRoot.informationFlows.filter(SignatureInformationFlow).toList()
				var foundMatchingIF = false
				for(flow : allFlows){
					if(flow.appliedTo.entityName.matches(opSig.entityName)){
						flow.information.add(info)
						foundMatchingIF = true
					}
				}
				if(!foundMatchingIF){
					createSignatureInformationFlow(opSig, info, c4cRoot, method)
				}
			}
		}
	}
}

routine createSignatureInformationFlow(pcm::OperationSignature opSig, c4c::ParameterInformation info, c4c::ConfidentialitySpecification c4cRoot, java::Method method){
	create{
		val flow = new c4c::SignatureInformationFlow
	}
	update{
		flow.appliedTo = opSig
		flow.information.add(info)
		c4cRoot.informationFlows.add(flow)
	}
}

/*
 * Changes the Parameter of the information corresponding to the sink if the Parameter of the sink is changed.
 */
reaction ParameterOfSinkChanged{
	after element java::OrdinaryParameter replaced at joana::Sink[annotatedParameter]
	call{
		changeParameterOfInfo(newValue, affectedEObject)
	}
}

/*
 * Changes the Parameter of the information corresponding to the source if the Parameter of the source is changed.
 */
reaction ParameterOfSourceChanged{
	after element java::OrdinaryParameter replaced at joana::Source[annotatedParameter]
	call{
		changeParameterOfInfo(newValue, affectedEObject)
	}
}

routine changeParameterOfInfo(java::Parameter javaPara, joana::Annotation anno){
	match{
		val info = retrieve c4c::ParameterInformation corresponding to anno
		val pcmPara = retrieve pcm::Parameter corresponding to javaPara
	}
	update{
		if(info.appliedTo !== null && pcmPara !== null){
			if(!pcmPara.identityEquals(info.appliedTo)){
				info.appliedTo = pcmPara
			}
		}
	}
}

